# Домашнее задание. Урок 33. Генераторы коллекций. list, dict, set comprehensions

## Краткая сводка
- **Проблемные блоки:** set comprehension (формат результата и приведение к верхнему регистру), аккуратное соблюдение формата строк при генерации списков.
- **Сильные стороны:** уверенный list/dict comprehension, точная фильтрация и агрегация, корректная организация кода.
- **Приоритеты:** закрепить set comprehension с преобразованием данных, освежить навыки по комбинированным условиям внутри list comprehension, потренировать dict comprehension с расчётами и подготовиться к следующему уроку (dict/set + условия).

## Задача 1. Повторение сложной темы — «приоритетные регионы поддержки»
- **Блок:** set comprehension.
- **Описание:** дан список словарей `requests`, каждый с полями `region`, `priority`, `service`. Построй множество `target_regions`, куда попадут только регионы:
  - `priority` в `{"high", "urgent"}`;
  - `service` в наборе `allowed_services`;
  - итоговое значение в верхнем регистре.
- **Пример входа:**
  ```python
  requests = [
      {"region": "msk", "priority": "urgent", "service": "backup"},
      {"region": "spb", "priority": "medium", "service": "backup"},
      {"region": "ekb", "priority": "high", "service": "sync"}
  ]
  allowed_services = {"backup", "sync"}
  ```
- **Ожидаемый вывод:** `{"MSK", "EKB"}`
- **Критерии:**
  1. Один set comprehension, без последующего `set(...)`.
  2. Регион приводится к верхнему регистру внутри выражения.
  3. Исходные данные не модифицируются.
  4. Строгая фильтрация по двум условиям.

## Задача 2. Закрепление практики — «обработка эскалаций»
- **Блок:** list comprehension + форматирование строк.
- **Описание:** список эскалаций `tickets = [{"id": 501, "owner": "Игорь", "level": 2, "status": "open"}, ...]`. Сформируй список строк `"Эскалация #ID (уровень L) — OWNER"` только для заявок:
  - `status == "open"`;
  - `level` от 2 до 4;
  - имя владельца непустое.
- **Граничные случаи:** если `owner` содержит пробелы по краям, его нужно обрезать методом `strip`.
- **Критерии:**
  1. Один list comprehension.
  2. Формат строки строго соответствует шаблону (длинное тире с пробелами).
  3. Условия фильтрации объединены внутри comprehension.
  4. Исходный список не меняется.

## Задача 3. Интеграция блоков — «сводка инфраструктурных кластеров»
- **Блоки:** dict comprehension, расчёты, фильтры.
- **Описание:** дан список `clusters = [{"name": "Core", "budget": 450000, "nodes": [{"city": "Moscow", "status": "online", "cost": 90000}, ...]}, ...]`.
  - Построй словарь `cluster_summary`, где ключ — имя кластера, значение — словарь `{"online": N, "cost": total}`:
    - `N` — количество нод со статусом `"online"`;
    - `total` — суммарная стоимость всех нод;
  - Включать только кластеры, где онлайн-нод ≥ 2 и суммарная стоимость не превышает бюджета.
- **Подсказка:** можно использовать вложенные генераторы внутри `sum`.
- **Критерии:**
  1. Один dict comprehension без внешних циклов.
  2. Проверка обоих условий до добавления элемента.
  3. Нет побочных эффектов.
  4. Результат легко считывается (структура словаря понятная).

## Задача 4. Подготовка к следующему занятию — «мониторинг таск-трекера»
- **Блок:** комбинированный анализ списков/множеств (подготовка к темам про структуры данных).
- **Описание:** дан список строк `logs = ["backend:create:15", "frontend:update:5", ...]`. Нужно:
  1. Построить set comprehension `slow_services`, куда попадают сервисы (первая часть строки) с операциями `create`/`sync`, если длительность ≥ 20.
  2. Построить list comprehension `brief`, где каждая строка `"service -> action (+duration)"` для записей с длительностью < 20.
  3. Вернуть оба объекта (set + list). Исходный список не менять.
- **Критерии:**
  1. Каждая структура создаётся одним comprehension без вспомогательных циклов.
  2. Корректная проверка формата строк (ровно две двоеточия).
  3. Длительность преобразуется в `int` ровно один раз на строку.
  4. Наличие комментария, если требуется пояснение (например, про разбор строки).

## Дедлайны и критерии оценки
- Сдать до **15 декабря, 23:59 (UTC+05:00)** одним коммитом в папку `homework/`.
- Анализируется только первый коммит, попавший в `homework/`. Если нужно добавить несколько файлов, загружай их одним коммитом.
- Каждая задача проверяется по трём группам:
  1. **Функциональность (50%)** — корректность условий и вычислений.
  2. **Качество кода (30%)** — лаконичные comprehensions, отсутствие дублирования, читаемость.
  3. **Стиль и проверки (20%)** — аккуратный вывод, работа с граничными случаями, никакого лишнего вывода.

**Важно:** тексты заданий индивидуальны, копирование запрещено. Внимательно следи за форматом, особенно в блоках, где ранее терялись баллы.
