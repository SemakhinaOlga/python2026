# Практическое задание 35.3

Это задание посвящено блоку «Гибкие функции: *args, **kwargs и распаковка». Вы уже научились работать с позиционными и именованными аргументами, а также со значениями по умолчанию. Сейчас вы переходите к созданию функций, которые могут принимать переменное количество данных, что является ключевым навыком для написания универсального кода. Это упражнение подготовит вас к работе с функциями, где количество входных параметров заранее неизвестно.

## Задания

### Описание задачи
Ольга, ваша задача — написать функцию `merge_data`, которая объединяет информацию из разных источников. Функция должна быть гибкой и принимать:
1. Обязательный позиционный аргумент `base` (словарь с основной информацией).
2. Произвольное количество дополнительных словарей через `**kwargs`.
3. Произвольное количество строк-меток через `*args`.

Функция должна выполнить следующие действия:
- Объединить все переданные словари (`base` и словари из `kwargs`) в один новый словарь. Если ключи повторяются, приоритет имеет значение из последнего переданного словаря (т.е., более поздние аргументы перезаписывают более ранние).
- Все строки-метки из `*args` добавить в итоговый словарь под ключом `tags` в виде списка.
- Вернуть итоговый объединенный словарь.

**Контекст:** Представьте, что вы формируете профиль пользователя из разных модулей системы (основные данные, настройки, контакты), а также добавляете к нему теги для категоризации.

### Пример входных и выходных данных

**Пример 1: Базовый случай**
```python
base_profile = {"name": "Ольга", "city": "Москва"}
additional_info = {"age": 30, "city": "Казань"}
contacts = {"email": "olga@example.com"}

result = merge_data(base_profile, "активный", "премиум", info=additional_info, contacts=contacts)
print(result)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Ольга',
    'city': 'Казань',  # Значение из `additional_info` перезаписало 'Москва'
    'age': 30,
    'email': 'olga@example.com',
    'tags': ['активный', 'премиум']
}
```
**Пояснение:** Словари `base_profile`, `info` и `contacts` объединены. Ключ `city` присутствовал в двух словарях, взято последнее значение ("Казань"). Строки "активный" и "премиум" собраны в список под ключом `tags`.

**Пример 2: Без дополнительных словарей и меток**
```python
base = {"id": 1}
result = merge_data(base)
print(result)
```
**Ожидаемый вывод:**
```python
{'id': 1, 'tags': []}
```
**Пояснение:** Так как `*args` и `**kwargs` не переданы, словарь `kwargs` пуст, а список `tags` создается пустым.

**Пример 3: Использование распаковки**
```python
default_settings = {"theme": "light", "notifications": True}
user_updates = {"theme": "dark"}
extra_tags = ["новый", "тест"]

# Распаковка списка тегов и словаря обновлений
result = merge_data(default_settings, *extra_tags, updates=user_updates)
print(result)
```
**Ожидаемый вывод:**
```python
{
    'theme': 'dark',  # Перезаписано из `user_updates`
    'notifications': True,
    'tags': ['новый', 'тест']
}
```
**Кодовая подсказка:** Обратите внимание, что `*extra_tags` распаковывается в позиционные аргументы для `*args`, а `updates=user_updates` передается как именованный аргумент в `**kwargs`.

### Критерии проверки и ограничения
1.  Функция должна называться `merge_data` и иметь следующую сигнатуру: `def merge_data(base, *args, **kwargs):`.
2.  Обязательно используйте `*args` для сбора строк-меток и `**kwargs` для сбора дополнительных словарей.
3.  Итоговый словарь должен содержать все пары ключ-значение из `base` и всех словарей в `kwargs`.
4.  При конфликте ключей (одинаковый ключ в нескольких словарях) должно сохраняться значение из последнего по порядку словаря.
5.  Ключ `"tags"` в итоговом словаре должен всегда присутствовать, его значением должен быть список всех строк из `*args`. Если строк нет, список должен быть пустым.
6.  **Важное ограничение:** В этой задаче не требуется и нельзя использовать темы из будущих блоков, такие как область видимости (`global`), замыкания или интеграция с другими концепциями. Фокус строго на `*args`, `**kwargs` и распаковке.

### Решение задачи (псевдокод)
1.  Создать новый словарь `result` и инициализировать его содержимым словаря `base`.
2.  Для каждого словаря, переданного через именованные аргументы (т.е., для каждого значения в `kwargs`):
    *   Обновить словарь `result` содержимым этого словаря. Эта операция автоматически перезапишет значения для существующих ключей.
3.  Добавить в словарь `result` ключ `"tags"`.
4.  Значением для ключа `"tags"` сделать список, содержащий все элементы, собранные в `args`.
5.  Вернуть словарь `result`.

### Рекомендации
-   Вынести в отдельную функцию: В данном случае вся логика сосредоточена в одной операции — объединении данных по четким правилам. Создание отдельной функции `merge_data` полностью соответствует требованию задачи и является хорошей практикой для изоляции этой логики.
-   PEP8:
    -   Используйте осмысленные имена переменных: `base`, `args`, `kwargs`, `result`.
    -   После определения функции `def merge_data(base, *args, **kwargs):` оставьте две пустые строки перед следующим элементом кода (например, перед примером вызова).
