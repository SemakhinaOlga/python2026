# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи

1.  **Функция для форматирования данных о товаре**
    -   **Описание задачи:** Тренирует базовое объявление функции, использование позиционных и именованных аргументов, а также оператора `return`. Задача учит отличать печать результата от его возврата, что является фундаментальным навыком.
    -   **Пример (вход → выход):**
        -   `format_product("Молоко", 90)` → `"Товар: Молоко, Цена: 90 руб."`
        -   `format_product(price=150, name="Хлеб")` → `"Товар: Хлеб, Цена: 150 руб."`
        -   `format_product("Яблоки")` → `"Товар: Яблоки, Цена: 0 руб."` (граничный случай: цена не указана)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `format_product`.
        -   Она должна принимать два параметра: `name` (обязательный) и `price` (необязательный, по умолчанию 0).
        -   Функция должна **возвращать** отформатированную строку, а не печатать ее.
        -   Внутри функции не должно быть вызова `print`.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `format_product` с параметрами `name` и `price` (для `price` задай значение по умолчанию 0).
        2.  Внутри функции создай строку по шаблону `"Товар: {name}, Цена: {price} руб."`.
        3.  Верни эту строку с помощью оператора `return`.
    -   **Рекомендации:**
        -   **PEP8:** Имя функции должно быть в `snake_case`. Используй пробелы вокруг оператора `=` при задании значения по умолчанию.

2.  **Безопасное добавление заметок в список**
    -   **Описание задачи:** Закрепляет понимание работы с изменяемыми значениями по умолчанию (списками) и применение безопасного паттерна с `None`. Это предотвратит одну из самых частых и коварных ошибок.
    -   **Пример (вход → выход):**
        -   `add_note("Купить молоко")` → `['Купить молоко']`
        -   `add_note("Позвонить маме")` → `['Позвонить маме']`
        -   `my_list = []; add_note("Первая", my_list); add_note("Вторая", my_list)` → `['Первая', 'Вторая']` (работа с переданным списком)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `add_note`.
        -   Она должна принимать два параметра: `note` (строка) и `notes_list` (список, по умолчанию `None`).
        -   Если `notes_list` равен `None`, внутри функции должен создаваться новый пустой список.
        -   Строка `note` должна добавляться в список `notes_list`.
        -   Функция должна возвращать измененный (или созданный) список.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `add_note` с параметрами `note` и `notes_list` (значение по умолчанию — `None`).
        2.  Внутри функции проверь, равен ли `notes_list` `None`.
        3.  Если да, создай новый пустой список и присвой его переменной `notes_list`.
        4.  Добавь `note` в список `notes_list`.
        5.  Верни список `notes_list`.
    -   **Рекомендации:**
        -   Для проверки на `None` используй оператор `is` (`if notes_list is None:`).
        -   **PEP8:** После двоеточия в условии `if` ставь пробел.

3.  **Универсальный калькулятор счета**
    -   **Описание задачи:** Развивает навык работы с `*args` для обработки переменного числа аргументов. Учит правильно обрабатывать граничный случай (отсутствие аргументов) и применять распаковку списка.
    -   **Пример (вход → выход):**
        -   `calculate_total(100, 200, 50)` → `350`
        -   `calculate_total(25)` → `25`
        -   `calculate_total()` → `0` (граничный случай: счет пуст)
        -   `prices = [10, 20, 30]; calculate_total(*prices)` → `60` (использование распаковки)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `calculate_total`.
        -   Она должна принимать произвольное количество позиционных аргументов (используй `*args`).
        -   Функция должна возвращать сумму всех переданных чисел.
        -   Если аргументы не переданы, функция должна вернуть 0.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate_total`, которая принимает `*args`.
        2.  Если длина `args` равна 0, верни 0.
        3.  Иначе, просуммируй все элементы в `args` и верни результат.
    -   **Рекомендации:**
        -   Для суммирования удобно использовать встроенную функцию `sum()`.
        -   **PEP8:** Параметр `*args` — это общепринятое имя, его не нужно менять.

4.  **Интеграция: Сборник рецептов с фильтрацией**
    -   **Описание задачи:** Объединяет несколько концепций: функции с параметрами по умолчанию, `**kwargs` для гибкой фильтрации, и управление областью видимости (работа с глобальным списком). Задача моделирует реалистичный сценарий.
    -   **Описание контекста:** У нас есть глобальный список `cookbook`, содержащий словари рецептов. Нужно написать функцию, которая может фильтровать рецепты по разным критериям (например, по времени приготовления, сложности, типу блюда).
    -   **Пример (вход → выход):**
        ```python
        cookbook = [
            {"name": "Омлет", "time": 10, "difficulty": "легко", "type": "завтрак"},
            {"name": "Борщ", "time": 120, "difficulty": "средне", "type": "обед"},
            {"name": "Салат", "time": 20, "difficulty": "легко", "type": "закуска"}
        ]

        # Поиск всех легких рецептов
        find_recipes(difficulty="легко") -> [{"name": "Омлет", ...}, {"name": "Салат", ...}]

        # Поиск быстрых обедов
        find_recipes(max_time=30, dish_type="обед") -> [] (пустой список, так как борщ готовится 120 мин.)

        # Поиск по названию (используем **kwargs для передачи любого ключа)
        find_recipes(name="Омлет") -> [{"name": "Омлет", ...}]
        ```
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `find_recipes`.
        -   Она должна принимать произвольные именованные аргументы через `**kwargs` для критериев фильтрации (например, `difficulty="легко"`, `max_time=30`).
        -   Функция должна итерироваться по глобальному списку `cookbook`.
        -   Для каждого рецепта нужно проверить, соответствуют ли ВСЕ переданные в `kwargs` критерии. Для критерия `max_time` нужно проверять `recipe["time"] <= max_time`.
        -   Функция должна возвращать список подходящих рецептов.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `find_recipes`, принимающую `**kwargs`.
        2.  Создай пустой список `result`.
        3.  Для каждого `recipe` в глобальном списке `cookbook`:
            1.  Предположи, что рецепт подходит (`is_match = True`).
            2.  Для каждой пары `key, value` в `kwargs`:
                -   Если `key` равен `"max_time"`, проверь `recipe["time"] <= value`.
                -   Иначе, проверь `recipe[key] == value`.
                -   Если проверка не прошла, установи `is_match = False` и прерви цикл проверки критериев.
            3.  Если `is_match` остался `True`, добавь `recipe` в список `result`.
        4.  Верни список `result`.
    -   **Рекомендации:**
        -   Для перебора пар ключ-значение в словаре `kwargs` используй метод `.items()`.
        -   **PEP8:** Если строка кода становится слишком длинной из-за вложенных циклов или условий, можно перенести логику во вспомогательную функцию (например, `_recipe_matches_criteria(recipe, filters)`), но это не обязательно для данного задания.
